{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Appunti Laboratorio di Reti di Calcolatori - UniMI","text":"<p>Benvenuti nella raccolta open-source di appunti, guide pratiche ed esercizi svolti per il corso di Laboratorio di Reti di Calcolatori, tenuto dai professori Christian Quadri e Gian Paolo Rossi presso l'Universit\u00e0 degli Studi di Milano (UniMI).</p> <p>Questo progetto nasce come supporto allo studio per gli studenti di Informatica, fornendo una guida passo-passo alle configurazioni di rete e all'analisi dei protocolli.</p>"},{"location":"#indice","title":"Indice:","text":"<ul> <li>Apparati di rete: Hub, Switch, Bridge, Router</li> <li>Cablaggi: Cavi Ethernet, Fibra, standard di terminazione, composizione del cablaggio</li> <li>Servizi di Rete: Implementazione pratica di DHCP, NAT (Network Address Translation) e ACL.</li> <li>Switching e VLAN: Configurazione di Trunk 802.1Q, Access Port e Router on a Stick.</li> <li>Routing IGP: Routing Statico, RIP (v1,v2), OSPF (Open Shortest Path First).</li> <li>Wireshark: Analisi del traffico di rete, cattura pacchetti e studio dello stack protocollare TCP/IP e ISO/OSI.</li> </ul> <p>Disclaimer</p> <p>Questa raccolta NON sostituisce in alcun modo il materiale didattico ufficiale fornito dai docenti o i libri di testo consigliati. \u00c8 da intendersi come un supporto integrativo per agevolare la comprensione pratica degli esercizi e il ripasso pre-esame.</p>"},{"location":"#come-contribuire","title":"Come Contribuire","text":"<p>Hai trovato un errore? Vuoi aggiungere un esercizio svolto o un approfondimento su un nuovo argomento?</p> <ol> <li>Vai sul Repository GitHub del progetto.</li> <li>Fai un Fork del repository.</li> <li>Proponi le tue modifiche tramite una Pull Request.</li> </ol>"},{"location":"#licenza-e-utilizzo","title":"Licenza e Utilizzo","text":"<p>Il materiale contenuto in questo sito \u00e8 distribuito liberamente per favorire lo studio e la collaborazione.</p> <p>Licenza Creative Commons</p> <p>Tutti i contenuti sono rilasciati sotto licenza CC BY-NC-SA 4.0 (Attribuzione - Non commerciale - Condividi allo stesso modo).</p> <ul> <li>Puoi: Scaricare, modificare e ridistribuire gli appunti.</li> <li>Devi: Citare l'autore originale (Emiddio Ingenito) e il link a questo sito.</li> <li>Non puoi: Utilizzare questo materiale per scopi commerciali senza esplicito consenso.</li> </ul>"},{"location":"ACL/","title":"ACL","text":"<p>Le ACL (Access Control Lists) sono elenchi di regole applicabili alle interfacce di un router, per definire la tipologia di traffico da scartare/inoltrare sia in uscita che in entrata.</p> <p>Per definire quali pacchetti scartare e quali inoltrare, \u00e8 possibile analizzare i seguenti criteri:</p> <ul> <li>Indirizzo IP Sorgente (Concedere solo determinati mittenti fidati)</li> <li>Indirizzo IP Destinazione</li> <li>Protocollo: TCP, UDP, ICMP (Ping).</li> <li>Porta Sorgente o Destinazione: 80 (HTTP), 443 (HTTPS), 23 (Telnet), 53 (DNS).</li> <li>Flag TCP: (es. bloccare solo l'inizio di una connessione SYN, ma permettere le risposte ACK -  Keyword <code>Established</code>).</li> </ul> <p>Tipologie di ACL configurabili:</p> <ul> <li> <p>ACL Standard (Identificate da un numero compreso tra 1 e 99) - Filtrano il traffico esclusivamente in base all\u2019indirizzo IP sorgente.</p> <p>Sintassi: <code>access-list &lt;ID 1-99&gt; {permit|deny} &lt;sorgente|wildcard-mask|any&gt;</code></p> </li> <li> <p>ACL Extended (ID 100-199) - Filtraggio per IP Sorgente e/o destinazione, protocollo di livello 3 o 4, numeri di porta, <code>Established</code>.</p> <p>Sintassi:<code>access-list &lt;ID 100-199&gt; {permit|deny} &lt;protocollo&gt; &lt;sorgente|wildcard|any&gt; &lt;destinazione|wildcard|any&gt; [eq/neq/lt/gt/range &lt;porta/range porte&gt;] [established] [log]</code></p> </li> <li> <p>ACL Extended Named - Le ACL Standard ed Extended hanno una limitazione: sono estensibili, ma non modificabili. Ci\u00f2 significa che se ho sbagliato ad impostare una regola di filtraggio, non \u00e8 possibile modificarla, devo cancellare l\u2019ACL e ricrearla.</p> <p>Sintassi:  <code>ip access-list extended NOME</code></p> <p>Le ACL Named, oltre ad essere pi\u00f9 comodamente identificate da un nome, e non un numero, associano ad ogni regola aggiunta, un ID progressivo multiplo di 10.</p> <p>Questo rende possibile sia eliminare regole precedentemente aggiunte, con la sintassi <code>no IDRegola</code>, sia inserire una nuova regola tra due precedentemente inserite.</p> <p>Esempio: </p> <pre><code>Router(config)# ip access-list extended BLOCCO_SOCIAL\nRouter(config-ext-nacl)# deny tcp 192.168.1.0 0.0.0.255 host 10.0.0.50 eq 80 //ID 10\nRouter(config-ext-nacl)# permit ip any any //ID 20\nRouter(config-ext-nacl)# 15 permit icmp any any //Ho inserito una regola tra la prima e la seconda.\nRouter(config-ext-nacl)# exit\n</code></pre> </li> </ul> <p>Creata l\u2019ACL, \u00e8 possibile applicarla ad un interfaccia di un router tramite i comandi:</p> <pre><code>Router(config)# interface &lt;interfaccia&gt; (es. GigabitEthernet0/0)\nRouter(config-if)# ip access-group &lt;NUMERO o NOME ACL&gt; &lt;in | out&gt;\n</code></pre> <ul> <li>IN - Il Router controlla le regole sul traffico in arrivo sull\u2019interfaccia</li> <li>OUT - Controllo delle regole sul traffico in uscita dall\u2019interfaccia</li> </ul> <p>Quando un pacchetto raggiunge il router su di un interfaccia configurata con ACL, il router controlla le regole in ordine di scrittura, per verificare se il pacchetto fa match con una delle regole (siano esse di permit o deny).</p> <p>In caso un pacchetto non faccia match con nessuna delle regola, vale allora esso verr\u00e0 implicitamente scartato.</p> <p>Per semplificare i comandi di inserimenti delle regole, \u00e8 possibile utilizzare degli alias al posto delle porte TCP:</p> <ul> <li><code>www</code>  -  Porta 80 (HTTP)</li> <li><code>telnet</code> - Porta 23</li> <li><code>smtp</code> - Porta 25 (Invio email)</li> <li><code>pop3</code> - Porta 110 (Ricezione email)</li> <li><code>ftp</code> - Porta 21 (File Transfer)</li> <li><code>domain</code> - Porta 53 (DNS - attenzione, usa spesso UDP)</li> </ul> <p>Esempio: <code>access-list 110 permit tcp any host 192.168.200.200 eq www</code> corrisponde a <code>access-list 110 permit tcp any host 192.168.200.200 eq 80</code></p>"},{"location":"ACL/#configurazione-acl-in-packet-tracer","title":"Configurazione ACL in Packet Tracer","text":""},{"location":"ACL/#esempio-1","title":"Esempio 1:","text":"<p>Vogliamo permettere l\u2019accesso al Web Server nella VLAN Gialla, ma bloccare il ping (ICMP).</p> <p></p> <pre><code>Router(config)#ip access-list extended ALLOW_WEB_SERVER\nRouter(config-ext-nacl)#permit TCP any host  192.168.200.200 eq www\nRouter(config-ext-nacl)#deny ICMP any any\nRouter(config-ext-nacl)#exit\nRouter(config)#interface fastEthernet 0/0.200\nRouter(config-subif)#ip access-group ALLOW_WEB_SERVER out\n</code></pre> <p>Nota: avrei potuto omettere la regola <code>deny ICMP any any</code>, facendo affidamento alla regola di default <code>deny IP any any</code>.</p> <p>Con il comando <code>show running-config</code>, notiamo come la ACL sia stata correttamente applicata all\u2019interfaccia</p> <pre><code>Router#show running-config \nBuilding configuration...\n\nCurrent configuration : 1072 bytes\n...\ninterface FastEthernet0/0\n no ip address\n duplex auto\n speed auto\n!\ninterface FastEthernet0/0.100\n encapsulation dot1Q 100\n ip address 192.168.100.254 255.255.255.0\n!\ninterface FastEthernet0/0.200\n encapsulation dot1Q 200\n ip address 192.168.200.254 255.255.255.0\n ip access-group ALLOW_WEB_SERVER out\n!\n...\n</code></pre>"},{"location":"ACL/#esempio-2","title":"Esempio 2:","text":"<p>Permettere a tutti gli host di accedere al Server Web pubblico, solo agli host interni alla VLAN di accedere anche a quello privato.</p> <p></p> <pre><code>Router(config)#ip access-list extended ALLOW_PUBLIC_SERVER\nRouter(config-ext-nacl)#permit TCP any host 192.168.0.1 eq www\nRouter(config-ext-nacl)#exit\nRouter(config)#interface fastEthernet 0/0\nRouter(config-if)#ip access-group ALLOW_PUBLIC_SERVER in\nRouter(config-if)#exit\n</code></pre> <p>Da questa configurazione, nessun host nella VLAN verde pu\u00f2 comunicare col server nella rete grigia: le richieste arrivano correttamente al server, ma le risposte vengono bloccate dalla ACL sul router (\u00e8 concesso solo il traffico TCP verso il server pubblico della VLAN verde, tutto il resto viene scartato)</p> <p>Modifichiamo cos\u00ec la ACL:</p> <pre><code>Router(config)#ip access-list extended ALLOW_PUBLIC_SERVER\nRouter(config-ext-nacl)#permit TCP any any established \nRouter(config-ext-nacl)#exit\n</code></pre> <p>Ora tutte le risposte (ma non le richieste) sono concesse.</p>"},{"location":"Apparati%20di%20rete/","title":"Apparati di rete","text":""},{"location":"Apparati%20di%20rete/#hub","title":"Hub","text":"<p>Sdoppiatore di porte che lavora a livello fisico.</p> <p></p> <p>Connettendo gli hosts alle porte disponibili, si ottiene una semplice connessione a rete bus, con tutte le limitazioni (anche in termini di prestazioni) dettate dalle possibili collisioni.</p> <p>In una topologia a bus, la connessione \u00e8 di tipo \u201chalf duplex\u201d: basta che due host trasmettano allo stesso momento, per far si che si verifichi una collisione.</p> <p>Il dominio di collisione corrisponde all\u2019intera rete.</p> <p>Non possiede alcun tipo di logica interna, tutti i frame ricevuti su una porta, vengono inoltrati a tutte le altre.</p>  \ud83d\udca1  Nota: L\u2019Hub inoltre i dati su tutte le porte, ma ogni host accetta i pacchetti in arrivo solo se il destination address corrisponde all\u2019indirizzo fisico della propria NIC."},{"location":"Apparati%20di%20rete/#switch","title":"Switch","text":"<p>Evoluzione dell\u2019hub. All\u2019esterno si presenta in modo simile, ma possiede al suo interno una logica di smistamento dei frame, che migliora notevolmente le prestazioni della rete.</p> <p></p> <p>Connettendo gli hosts alle porte disponibili, si ottiene una rete a stella, in cui lo switch \u00e8 il nodo centrale.</p> <p>Tutti i frame ethernet passano quindi per lo switch, ma la logica interna al dispositivo, veicola il traffico ai soli hosts destinatari.</p> <p>Durante la trasmissione di un frame in modalit\u00e0 broadcast, lo switch proceder\u00e0 ad inoltrarne una copia su tutte le porte connesse (tranne quella d\u2019ingresso)</p> <p>Per far si che il traffico dati venga indirizzato solo agli hosts interessati, gli switch mantengono in una memoria interna volatile CAM (Content Addressable Memory, memorie di tipo associativo indirizzabili in base al contenuto, in cui la ricerca avviene in tempo costante), una tabella MAC (anche detta Forwarding Table), in cui viene tenuta traccia dell\u2019associazione tra gli indirizzi MAC degli hosts nella rete, e la porta fisica dello switch ai quali tali hosts sono connessi.</p> <p>Il processo di funzionamento dello switch, permette di \u201criempire\u201d e mantenere aggiornate le informazioni contenute all\u2019interno della tabella, in modo trasparente ed automatico:</p> <ul> <li> <p>Learning - Lo switch riceve un frame ethernet: legge il MAC sorgente, controlla se nella CAM table, esiste gi\u00e0 un\u2019entry per tale MAC address. Se non esiste, tiene traccia dell\u2019associazione MAC-Porta d\u2019ingresso dalla quale tale frame \u00e8 arrivato.</p> <p> <p>Se esiste gi\u00e0 un\u2019entry per lo stesso MAC, ma associata ad una porta diversa, la entry viene aggiornata. Questo permette la mobilit\u00e0 fisica degli hosts.</p> <li> <p>Forwarding - Lo switch procede ad analizzare il MAC destinazione:</p> <ul> <li>Se esiste una entry nella CAM table, viene ricavata la corrispondente porta, ed il frame viene correttamente inoltrato in modalit\u00e0 unicast</li> <li> <p>Altrimenti, il frame viene inondato (flooding) su tutte le porte dello switch, tranne quella di ingresso.</p> <p> <p>Inoltrando il traffico in modalit\u00e0 flooding, il destinatario sicuramente ricever\u00e0 una copia del frame ethernet.</p> <p>Quando esso risponder\u00e0, lo switch provveder\u00e0 tramite la fase di learning, a tener traccia dell\u2019associazione del MAC del destinatario, pertanto la prossima trasmissione avverr\u00e0 in modalit\u00e0 unicast.</p> <li> <p>Filtering - Esistono situazioni in cui gli switch decidono di scartare frame definiti inutili o dannosi. Alcuni esempi:</p> <ul> <li>Un frame non viene mai rispedito indietro sulla porta da cui \u00e8 arrivato</li> <li>Se il MAC sorgente e destinazione corrispondono, o sono diversi ma si trovano sulla stessa porta, il frame viene scartato.</li> </ul> </li>   Tra queste funzioni, gli switch incorporano anche un meccanismo di \u201caging\u201d, per evitare che la tabella si riempia con informazioni obsolete.  Ogni entry appresa dinamicamente, \u00e8 associata ad un timer (generalmente di 300 secondi): quando un frame associato a tale MAC (sorgente o destinazione) entra nello switch, il timer viene rinnovato.  Allo scadere, l\u2019entry viene rimossa.     Generalmente, gli switch sono catalogati come apparati di rete di livello 2, anche se ne esistono versioni in grado di lavorare anche a livello 3."},{"location":"Apparati%20di%20rete/#bridge","title":"Bridge","text":"<p>Dispositivo di livello 2, che permette di collegare due segmenti di rete diversi, facendo in modo che appaiano come una rete unica.</p>   Gli switch collegano i singoli host, i bridge collegano segmenti di rete.   <p>Pu\u00f2 essere utilizzato anche per interconnettere reti che operano su tecnologie diverse: per esempio, i router casalinghi, integrano anche la funzionalit\u00e0 di bridge, per far si che dispositivi collegati in Wi-Fi e altri collegati via cavo, possano comunicare trasparentemente.</p>"},{"location":"Cablaggi/","title":"Cablaggi","text":""},{"location":"Cablaggi/#cavi-ethernet","title":"Cavi Ethernet","text":"<p>Un cavo ethernet, \u00e8 composto da 4 coppie di cavi intrecciati (Twisted Pair), connesse alle estremit\u00e0 da connettori RJ45.</p> <p></p> <p>I cavi sono disposti in coppie ritorte, al fine di ridurre le interferenze con le coppie vicine, annullandosi a vicenda gli effetti dei campi magnetici (diafonia).</p> <p>Il segnale viene inviato su un solo cavo della coppia: sull\u2019altro, viaggia un segnale costante a 0 (terra).</p> <p>Questo meccanismo, permette al destinatario di ricavare un segnale privo di rumore, operando per differenza tra i due segnali sui due cavi.</p> <p></p> <p>Supponiamo un trasmettitore voglia inviare un\u2019informazione s(t).</p> <p>Durante la trasmissione lungo il canale, vengono introdotte delle imperfezioni all\u2019interno del dato, che apparir\u00e0 modificato (s\u2019(t))</p> <p>Come fa il ricevitore a \u201cripulire\u201d il segnale, e ricavare il dato originale?</p> <p></p> <p>Segnale originale, immesso dal trasmettitore sul canale.</p> <p></p> <p>Imperfezioni introdotte dal canale. Notiamo come il rumore altera il segnale dei due cavi allo stesso modo!</p> <p></p> <p></p> <p>Il ricevitore, applicando una differenza tra i due segnali, ricostruisce correttamente s(t).</p>"},{"location":"Cablaggi/#tipologie-di-cavo","title":"Tipologie di cavo","text":"<ul> <li>UTP - Unshielded Twisted Pairs, non forniscono protezione da EMI</li> <li>FTP - Foiled Twisted Pairs, le 4 coppie ritorte, sono racchiuse da un foglio di alluminio.</li> <li>STP - Shielded Twisted Pairs, le singole coppie ritorte sono racchiuse da un foglio di alluminio o maglia in rame.</li> <li>SFTP - Shielded Foiled Twisted Pair, le singole coppie ritorte sono schermate, e infine un unico foglio di alluminio le racchiude assieme. Massimo livello di protezione EMI.</li> </ul>"},{"location":"Cablaggi/#standard-di-terminazionecrimpatura-connettori","title":"Standard di terminazione/crimpatura connettori","text":"<p>Esistono due standard che definiscono l\u2019ordine dei fili all\u2019interno del connettore RJ45.</p> <p></p> <ul> <li>T568A - Assegna le coppie verde e arancione in modo compatibile con vecchi impianti telefonici USOC, affinch\u00e9 fosse pi\u00f9 semplice ricordare l\u2019ordine di terminazione.</li> <li>T568B - Standard commerciale oggi pi\u00f9 utilizzato.</li> </ul>   Non cambia assolutamente nulla utilizzare uno piuttosto che l\u2019altro standard. L\u2019importante ovviamente \u00e8 usare lo stesso standard alle due estremit\u00e0 del cavo, per il resto l\u2019ordine dei colori cambia nulla."},{"location":"Cablaggi/#cavi-ethernet-straight-e-crossed","title":"Cavi Ethernet Straight e Crossed","text":"Faremo riferimento allo standard di terminazione T568B, in quanto T568A \u00e8 ora in disuso.   <p>Gli standard BASE-T (10BASE-T, 100BASE-TX, 1000BASE-T) definiscono come Ethernet trasmette i bit sul doppino</p> <p>10BASE-T e 100BASE-T, prevedono la comunicazione dei dati (in modalit\u00e0 unidirezionale) su sole due delle 4 coppie presenti nel cavo.</p> <p>Coppia 1 (Composta dai pin 1 e 2),  Coppia 2 (Composta dai pin 3 e 6)</p> <p>Esistono due standard che descrivono come le porte ethernet dei dispositivi sono cablate:</p> <p>MDI (Medium Dependent Interface) - Usato dai dispositivi terminali (PC, Server, Stampanti\u2026), usano la coppia 1 per trasmissione, coppia 2 per ricezione.</p> <p>MDIX (MDI eXchanged) - Usato dai dispositivi infrastrutturali (Switch, Hub..), usano coppia 1 per ricezione, coppia 2 per trasmissione.</p> <p>I ruoli sono speculari, mettendo \u201cuna davanti all\u2019altra\u201d due porte MDI e MDIX, i pin di trasmissione di una finiscono su quelli di ricezione dell\u2019altra, e idem per l\u2019altra coppia.</p> <p></p> <p>Ma se volessi far comunicare due dispositivi le cui porte ethernet sono cablate attraverso lo stesso schema? (Entrambe MDI o MDIX)</p> <p>A quel punto, dovrei \u201cmanualmente\u201d effettuare l\u2019inversione delle coppie di pin TX ed RX. Ecco da cosa deriva l\u2019uso di cavi straight e crossed.</p> <p></p> <p>Se i due dispositivi che voglio mettere in comunicazione, possiedono porte ethernet internamente collegate secondo standard opposti (MDI e MDIX), uso un cavo straight (l\u2019inversione delle coppie RX e TX \u00e8 gi\u00e0 effettuata), altrimenti uso un cavo crossed (l\u2019inversione RX e TX avviene modificando lo schema di terminazione dei pin all\u2019interno del cavo)</p> <p>Con lo standard 1000BASE-T, la comunicazione avviene utilizzando simultaneamente tutte e 4 le coppie ritorte bi-direzionalmente (sia in trasmissione che ricezione). </p> <p>Non esiste pi\u00f9 la distinzione tra coppie di trasmissione e coppie di ricezione.</p> <p>Tale standard, prevede l\u2019utilizzo della tecnologia Auto MDI/MDI-X, che permette alle PHY di identificare automaticamente com\u2019\u00e8 cablato il dispositivo che si trova all\u2019altra estremit\u00e0 del cavo, invertendo eventualmente la mappatura dei pin tramite switch analogici.</p> <p>Esempio: Collego un PC con NIC Auto-MDI/MDI-X, ad un dispositivo MDI. La NIC del PC si autoconfigura come MDI-X. Il link funziona con qualsiasi cavo (straight o cross)</p> <p>Collego un PC con NIC Auto-MDI/MDI-X ad un dispositivo MDI-X. Il PC si configura come MDI, anche qui il link funziona indipendentemente dal cavo</p> <p>Collegando un PC con Auto-MDI/MDI-X con un dispositivo senza Auto-MDI/MDI-X, il link funziona nel 100% dei casi, indipendentemente dal cavo.</p> <p>Tabella riassuntiva sull\u2019uso corretto dei cavi cross e straight:</p> <p></p>   \u201cLe NIC oggi sono ancora \u201ccablate\u201d come MDI e MDI-X?\u201d  **Tecnicamente s\u00ec**, ma con un\u2019importante precisazione.  A livello FISICO (cablatura dei pin):  - Le NIC dei PC seguono ancora la mappatura storica **MDI**:     - coppia 1 (pin 1\u20132) \u2192 TX locale     - coppia 2 (pin 3\u20136) \u2192 RX locale - Quelle dei dispositivi intermedi, sono ancora collegati MDI-X  Questo *schema di cablatura interna* rimane per compatibilit\u00e0 storica, perch\u00e9 lo standard RJ-45 e il pinout fisico non sono stati cambiati. Tuttavia **la cablatura fisica non determina pi\u00f9 il comportamento del link,** perch\u00e9 entra in gioco la logica di **Auto-MDI/MDI-X nella PHY**.  La PHY moderna:  - guarda come sono effettivamente cablate le coppie, - analizza i FLP (Fast Link Pulses) di autonegotiation, - capisce se il dispositivo remoto \u00e8 MDI o MDI-X, - e se serve, **inverte internamente TX/RX tramite switch analogici + DSP**."},{"location":"Cablaggi/#fibra-ottica","title":"Fibra ottica","text":"<p>La trasmissione di segnali mediante tecnologia fibra ottica, consiste nell\u2019invio di impulsi luminosi, che possono essere elaborati dal computer.</p> <p>La luce viaggia seguendo una traiettoria rettilinea, finch\u00e9 non colpisce un oggetto che la riflette, rifrange, o assorbe.</p> <p>Riflessione</p> <ul> <li>Definizione:\u00a0La luce incontra una superficie (come uno specchio) e viene deviata indietro nello stesso mezzo.</li> </ul> <p>Riflessione</p> <ul> <li>Definizione:\u00a0La luce incontra una superficie (come uno specchio) e viene deviata indietro nello stesso mezzo.</li> </ul> <p>La fibra ottica \u00e8 studiata per minimizzare la riflessione, e massimizzare la rifrazione (eliminando l\u2019assorbimento).</p> <p>Un cavo in fibra ottica, \u00e8 composto da:</p> <p></p> <ul> <li>Core - In cui gli impulsi luminosi viaggiano, composto da vetro al silicio estremamente puro (privo di contaminazioni). Questa propriet\u00e0 \u00e8 necessaria affinch\u00e9 la luce possa viaggiare senza degradarne la qualit\u00e0.</li> </ul> <p></p> <ul> <li>Cladding - Un ulteriore strato di vetro, meno puro rispetto al core, che lo racchiude per l\u2019intera lunghezza del cavo. Agisce come riflettore, mantenendo la luce all\u2019interno del core, impedendo che esca al di fuori.</li> <li>Coating - Strato in gomma, che protegge il vetro della fibra da graffi e agenti atmosferici.</li> </ul>"},{"location":"DHCP/","title":"DHCP","text":"<p>DHCP (Dynamic Host Configuration Protocol) \u00e8 un protocollo applicativo per la configurazione automatica dei parametri di rete degli host in una rete locale.</p> <p>Obiettivo pratico: permettere a un client senza indirizzo (o con indirizzo temporaneo) di ricevere indirizzi e parametri in modo scalabile e centralizzato.</p> <p>Esempio: il computer \u201cpippo\u201d si collega fisicamente alla rete (Cavo Ethernet, o via etere).</p> <p></p> <p>Nello stato iniziale esso non ha un indirizzo IP, potr\u00e0 inviare solo frame ethernet a livello 2 (datalink, identificandosi utilizzando l\u2019indirizzo MAC).</p> <ol> <li>Il software DHCP in esecuzione sul PC \u201cpippo\u201d, rileva la connessione e comincia la trasmissione di frame ethernet DHCP DISCOVER all\u2019indirizzo fisico di broadcast FF:FF:FF:FF:FF:FF, con l\u2019intento di identificare un eventuale server DHCP presente sulla rete.</li> <li>Il server DHCP raggiungo da un pacchetto DHCP DISCOVER, risponde con un frame ethernet DHCP OFFER, inoltrato anch\u2019esso in modalit\u00e0 broadcast, contenente:<ul> <li>Indirizzo IP (libero, non in uso) proposto per il client</li> <li>Maschera di sottorete (Subnet Mask)</li> <li>Default gateway</li> <li>Indirizzo del server DNS</li> <li>Lease duration</li> <li>Altri eventuali parametri specifici della rete (Esempio: nome di dominio di default)</li> </ul> </li> <li>Il client \u201cpippo\u201d, ricevuta la configurazione, invia in broadcast una DHCP REQUEST, chiedendo di riservare per lui l\u2019indirizzo indicato.</li> <li>Il server DHCP risponde con un frame ethernet inviato in broadcast, con un DHCP ACK, per confermare al client che pu\u00f2 procedere a salvare la configurazione di rete pattuita.</li> </ol> <p></p> <p>Al termine della procedura, il client sar\u00e0 libero di utilizzare l\u2019indirizzo IP fornitogli per un quanto di tempo \u201cLease time\u201d.</p> <p>A met\u00e0 del Lease time, il client chieder\u00e0 di rinnovare il permesso di utilizzare quell\u2019indirizzo, mandando al server DHCP una nuova DHCP REQUEST, trasmessa in Unicast, a cui il server risponder\u00e0 con un DHCP ACK, sempre in Unicast al client.</p> <p></p> <p>L\u2019indirizzo IP viene rilasciato o esplicitamente dal client, quando esso si disconnette dalla rete, tramite un pacchetto DHCP RELEASE, oppure alla scadenza del time lease.</p> <p></p>"},{"location":"DHCP/#configurazione-packet-tracer","title":"Configurazione Packet Tracer:","text":"<ul> <li> <p>Aggiungere un server nella LAN, ed assegnargli dal menu \u201cConfig\u201d, un indirizzo IP statico, subnet mask, e default gateway.</p> <p>Se il server \u00e8 connesso ad uno switch, la relativa interfaccia sullo switch deve essere configurato in modalit\u00e0 Access.</p> </li> </ul> <p></p> <p></p> <ul> <li> <p>Attivare il servizio DHCP sul server, e creare un pool (o modificare il serverPool di default) in cui specifichiamo le impostazioni comuni della rete, da assegnare ad ogni host al suo interno.</p> <p></p> </li> <li> <p>Ora, ogni host della rete in cui si trova il server DHCP, potr\u00e0 essere automaticamente configurato.</p> <p></p> </li> </ul>"},{"location":"DHCP/#dhcp-relay-agent-proxy","title":"DHCP Relay Agent (Proxy)","text":"<p>Vogliamo ora permettere anche agli host nella VLAN blu di utilizzare il servizio DHCP.</p> <p>Utilizziamo un DHCP Relay Agent, un dispositivo di rete intermediario tra il server DHCP ed i client, che permette di inoltrare le richieste DHCP dei client in una rete, ad un server DHCP appartentente ad un\u2019altra rete.</p> <p>The concept of DHCP proxy emerged as networks grew in complexity and size. Originally, DHCP was designed for simple, flat networks where clients and servers resided on the same segment. However, as networks expanded, spanning multiple segments and subnets, the need for a more versatile DHCP mechanism became apparent. The DHCP proxy was developed to bridge this gap, facilitating DHCP communication across different network segments, which was previously unattainable with standard DHCP operations. </p> <p>Come funziona:</p> <ul> <li>Un client della rete A invia un frame DHCP DISCOVER in broadcast.</li> <li>Il DHCP Relay Agent della rete A riceve il frame, e inoltra un nuovo pacchetto contenente:<ul> <li>Indirizzo IP di destinazione pari a quello del server DHCP</li> <li>Indirizzo IP mittente pari al proprio IP</li> <li>Un informazione relativa alla rete in cui si trova il client che ha richiesto il servizio DHCP: questa viene generalmente ricavata dall\u2019IP dell\u2019interfaccia da cui il Relay Agent ha ricevuto il frame DHCP DISCOVER</li> </ul> </li> <li>Il Server DHCP riceve il pacchetto, tramite l\u2019informazione della rete del client, consulta l\u2019elenco dei propri pool e procede a proporre una configurazione di rete (DHCP OFFER), inoltrandola al Relay Agent.</li> <li>Il Relay Agent inoltra l\u2019offer al client</li> </ul> <p>Il processo DORA (Discover, Offer, Request, Ack) continua passando per il relay agent.</p>"},{"location":"DHCP/#configurazione-packet-tracer_1","title":"Configurazione Packet Tracer","text":"<p>Per far si che un router operi come DHCP Proxy:</p> <ul> <li> <p>Nella modalit\u00e0 di configurazione della sotto-interfaccia della VLAN servita (Quella in cui non \u00e8 presente il server DHCP)</p> <pre><code>**Router(config-subif)# ip helper-address &lt;indirizzo DHCP server&gt;**\n</code></pre> <p>Ora anche i client della rete blu (192.168.0.0) potranno utilizzare il servizio DCHP.</p> <p></p> </li> </ul>"},{"location":"NAT/","title":"NAT (Network Address Translation)","text":"<p>Il protocollo IPv4 prevede l\u2019assegnazione ad ogni dispositivo connesso in rete di un indirizzo a 32 bit, lunghezza sufficiente a definire circa 4,3 miliardi di indirizzi unici.</p> <p>La rapida espansione di internet ha generato la necessit\u00e0 di pi\u00f9 indirizzi univoci, motivo per il quale \u00e8 iniziata la migrazione ad IPv6.</p> <p>Per prolungare la vita di IPv4, sono stati introdotti gli indirizzi IP privati.</p> <p>L'idea alla base \u00e8 semplice: non \u00e8 necessario che ogni dispositivo (stampante, PC aziendale, smartphone domestico) abbia un indirizzo IP pubblico univoco raggiungibile da tutto il mondo, \u00e8 sufficiente che sia identificabile univocamente solo all'interno della sua rete locale (LAN).</p> <p>Lo standard RFC 1918 ha riservato tre blocchi di indirizzi specifici per l'uso privato, riutilizzabili all'infinito in reti diverse, purch\u00e9 isolate tra loro.</p> <p>IPv4 Private IP Ranges (RFC 1918)</p> <ul> <li>Class A Block: <code>10.0.0.0</code>\u00a0\u2013\u00a0<code>10.255.255.255</code>\u00a0(CIDR:\u00a0<code>10.0.0.0/8</code>)</li> <li>Class B Block: <code>172.16.0.0</code>\u00a0\u2013\u00a0<code>172.31.255.255</code>\u00a0(CIDR:\u00a0<code>172.16.0.0/12</code>)</li> <li>Class C Block: <code>192.168.0.0</code>\u00a0\u2013\u00a0<code>192.168.255.255</code>\u00a0(CIDR:\u00a0<code>192.168.0.0/16</code>)</li> </ul> <p>Non Instradabilit\u00e0</p> <p>Gli indirizzi privati non sono instradabili su Internet. I router dei provider (ISP) sono configurati per scartare (drop) qualsiasi pacchetto che abbia come destinazione o sorgente un indirizzo IP appartenente a queste classi. Ci\u00f2 significa che un dispositivo a cui \u00e8 assegnato un indirizzo IP privato, non potr\u00e0 comunicare con la rete pubblica utilizzando quello stesso indirizzo.</p> <p>La soluzione \u00e8 il NAT, un meccanismo di traduzione di indirizzi pubblici in privati e viceversa, adottato dai router di confine d\u2019area al fine di permettere la navigazione in rete di dispositivi a cui \u00e8 assegnato un indirizzo privato.</p>"},{"location":"NAT/#nat-statico","title":"NAT Statico:","text":"<p>Associa ad ogni dispositivo all\u2019interno di una rete privata (indirizzato al suo interno da un indirizzo privato), un indirizzo IP pubblico fisso.</p> <p>Mappatura 1 a 1, necessito di tanti indirizzi IP pubblici tanti quanti sono gli host che vogliono comunicare in rete (un indirizzo pubblico per ogni indirizzo privato).</p> <p>Utilizzato principalmente in ambiente server, assegnando ad ognuno un indirizzo IP pubblico fisso.</p>"},{"location":"NAT/#funzionamento-del-nat-statico","title":"Funzionamento del NAT Statico:","text":"<p>Un client con indirizzo IP <code>8.8.8.8</code> (supponiamo pubblico e statico), richiede un servizio fornito dal server con indirizzo IP pubblico <code>200.200.200.1</code>:</p> <ol> <li> <p>Il client invia un pacchetto attraverso internet.</p> <p>Source: <code>8.8.8.8</code></p> <p>Destination: <code>200.200.200.1</code> (IP Pubblico del Server)</p> </li> <li> <p>Il router della rete in cui si trova il server, riceve il pacchetto sull'interfaccia Outside.</p> <p>Controlla la NAT Table e trovala regola statica di conversione 200.200.200.1 \u2192 192.168.0.1: modifica l'header del pacchetto</p> <p>Source: <code>8.8.8.8</code> (Invariato)</p> <p>New Destination: <code>192.168.0.1</code> (IP Privato)</p> </li> <li> <p>Il router cerca nella routing table <code>192.168.0.1</code> , inoltra correttamente il pacchetto al server.</p> </li> <li> <p>Il server risponde con la pagina web inviando un pacchetto al suo gateway (il router).</p> <p>Source: <code>192.168.0.1</code> (IP Privato)</p> <p>Destination: <code>8.8.8.8</code></p> </li> <li> <p>Il router riceve il pacchetto sull'interfaccia Inside. Ricontrolla la NAT Table, sostituisce l\u2019indirizzo IP Privato del server al fine di renderlo instradabile pubblicamente:</p> <ul> <li>New Source: <code>200.200.200.1</code> (IP Pubblico)</li> <li>Destination: <code>8.8.8.8</code> (Invariato)</li> </ul> </li> <li>Il pacchetto viaggia su Internet. Il Client riceve la risposta credendo che sia arrivata da <code>200.200.200.1</code></li> </ol>"},{"location":"NAT/#configurazione-nat-statico-in-packet-tracer","title":"Configurazione NAT statico in Packet Tracer:","text":"<p>Per abilitare il NAT, il router di confine d\u2019area della LAN deve sapere quali interfacce appartengono alla rete interna (da tradurre) e quali alla rete esterna (internet).</p> <p>Marcatura dell\u2019interfaccia connessa alla LAN:</p> <pre><code>Router(config)# interface [GigabitEthernet0/0]\nRouter(config-if)# ip nat inside\nRouter(config-if)# exit\n</code></pre> <p>Marcatura dell\u2019interfaccia connessa ad internet:</p> <pre><code>Router(config)# interface [Serial0/0/0]\nRouter(config-if)# ip nat outside\nRouter(config-if)# exit\n</code></pre> <p>In modalit\u00e0 di configurazione globale, impostiamo manualmente le regole di conversione tra IP Privati e pubblici.</p> <pre><code>Router(config)# ip nat inside source static PRIVATE_IP PUBLIC_IP\n</code></pre>"},{"location":"NAT/#nat-dinamico","title":"NAT Dinamico:","text":"<p>All\u2019interno del router di confine d\u2019area della LAN, \u00e8 caricato un pool (insieme) di indirizzi IP pubblici, ed ogni host interno alla rete, potr\u00e0 comunicare all\u2019esterno utilizzando uno degli IP presenti in esso.</p> <p>Esempio: potrei aver acquistato e caricato sul router 3 indirizzi IP pubblici, ma aver 50 host configurati nella LAN, come possono navigare tutti contemporaneamente su internet?</p> <p>Non \u00e8 possibile, il mio router permetter\u00e0 solo a 3 host contemporaneamente di comunicare in rete.</p> <p>Per configurare NAT Dinamico pertanto servono:</p> <ul> <li>Pool di indirizzi pubblici</li> <li>Elenco di indirizzi privati che andranno tradotti</li> </ul> <p>Attenzione! Non specifico una mappatura 1 a 1 come nel caso del NAT Statico, perch\u00e8 l\u2019assegnazione di un indirizzo pubblico piuttosto che un\u2019altro, \u00e8 dinamica, \u201ccasuale\u201d, non definita univocamente tramite mappatura pre-configurata. </p>"},{"location":"NAT/#configurazione-nat-dinamico-in-packet-tracer","title":"Configurazione NAT Dinamico in Packet Tracer:","text":"<p>Marcatura dell\u2019interfaccia connessa alla LAN:</p> <pre><code>Router(config)# interface [GigabitEthernet0/0]\nRouter(config-if)# ip nat inside\nRouter(config-if)# exit\n</code></pre> <p>Marcatura dell\u2019interfaccia connessa ad internet:</p> <pre><code>Router(config)# interface [Serial0/0/0]\nRouter(config-if)# ip nat outside\nRouter(config-if)# exit\n</code></pre> <p>Configuro una ACL contenente l\u2019elenco degli indirizzi d\u2019origine che andranno tradotti (a cui vogliamo permettere la navigazione in internet).</p> <p>Sintassi del comando: <code>access-list numeroACL permit/deny SOTTOINSIEME_INDIRIZZI_DA_TRADURRE WILDCARD_MASK</code></p> <pre><code># Definisco quali IP possono essere tradotti\nRouter(config)# access-list 110 permit ip 192.168.0.0 0.0.0.15 any\n</code></pre> <p>Per concedere a tutti gli host configurati nella LAN di accedere ad internet (traduzione di tutti gli host nella LAN), posso utilizzare la sintassi</p> <pre><code>Router(config)# access-list numeroACL permit ip any any\n</code></pre> <p>Configurazione Pool di indirizzi pubblici e abilitazione del NAT dinamico:</p> <pre><code>Router(config)# ip nat pool NAME FIRST_IP_ADDRESS LAST_IP_ADDRESS netmask SUBNET_MASK\nRouter(config)# ip nat inside source list ACL_NUMBER pool NAME (Stesso nome dato al POOL di indirizzi)\n</code></pre>"},{"location":"NAT/#nat-overload-pat-port-address-translation","title":"NAT \u201cOverload\u201d (PAT, Port Address Translation):","text":"<p>Singolo indirizzo IP Pubblico (Assegnato dall\u2019ISP e configurato sul Router), con cui tutti i dispositivi nella LAN comunicano.</p> <p>Per distinguere quale dispositivo richiede la connessione, e a quale di conseguenza inoltrare i pacchetti in entrata (essendo che ora tutti gli host nella LAN comunicano all\u2019esterno utilizzando lo stesso IP Pubblico), viene applicato un meccanismo di conversione dei numeri di porta detto PAT, con l\u2019utilizzo di una PAT table.</p>"},{"location":"NAT/#funzionamento-del-nat-overload","title":"Funzionamento del NAT \u201cOverload\u201d","text":"<p>Due client nella rete interna, PC A (<code>192.168.0.1</code>) e PC B (<code>192.168.0.2</code>), vogliono visitare contemporaneamente lo stesso sito web (<code>8.8.8.8</code>).</p> <p>Il router ha un solo indirizzo IP Pubblico: <code>200.200.200.1</code></p> <ol> <li> <p>Invio richieste: Il PC A apre il browser, il S.O assegna al processo una porta casuale (es. 3001). Source: <code>192.168.0.1 : 3001</code> (IP Privato : Porta A) Destination: <code>8.8.8.8 : 80</code> (IP Web Server : Porta HTTP) Il Router riceve il pacchetto del PC A, nota che \u00e8 da inoltrare al di fuori della LAN, sostituisce il suo IP pubblico nell\u2019header IP e assegna una nuova porta libera.</p> <p>New Source: <code>200.200.200.1 : 6001</code> (IP Pubblico : Porta Assegnata dal Router) Destination: <code>8.8.8.8 : 80</code> (Invariato)</p> <p>Memorizza tale associazione nella NAT Table (che ora memorizzer\u00e0 le associazioni IP-Port).</p> <p>Anche il PC B apre il browser. Per coincidenza, usa la stessa porta sorgente interna (3001). Source: <code>192.168.0.2 : 3001</code> (IP Privato : Porta B) Destination: <code>8.8.8.8 : 80</code> Il router assegna una nuova porta libera (es. 6002), e sostituisce il proprio IP New Source: <code>200.200.200.1 : 6002</code> (IP Pubblico : Porta Diversa) Destination: <code>8.8.8.8 : 80</code> Memorizza la nuova associazione.</p> <p>I due pacchetti vengono inoltrati sulla rete</p> </li> <li> <p>Reply:</p> <p>Il Server risponde alla prima richiesta: Source: <code>8.8.8.8 : 80</code> Destination: <code>200.200.200.1 : 6001</code> Il router riceve il pacchetto, legge la Porta di Destinazione (6001).</p> <p>Consultando la NAT Table, rileva che a <code>200.200.200.1: 6001</code>, corrisponde l\u2019host A: <code>192.168.0.1 : 3001</code>. Source: <code>8.8.8.8 : 80</code></p> <p>New Destination: <code>192.168.0.1 : 3001</code></p> <p>Il pacchetto viene consegnato a PC A.</p> <p>La stessa procedura si ripete per il PC B.</p> </li> </ol>"},{"location":"NAT/#configurazione-nat-overload-in-packet-tracer","title":"Configurazione NAT \u201cOverload\u201d in Packet Tracer:","text":"<p>Marcatura dell\u2019interfaccia connessa alla LAN:</p> <pre><code>Router(config)# interface [GigabitEthernet0/0]\nRouter(config-if)# ip nat inside\nRouter(config-if)# exit\n</code></pre> <p>Marcatura dell\u2019interfaccia connessa ad internet:</p> <pre><code>Router(config)# interface [Serial0/0/0]\nRouter(config-if)# ip nat outside\nRouter(config-if)# exit\n</code></pre> <p>Configuro una ACL contenente l\u2019elenco degli indirizzi d\u2019origine che andranno tradotti (a cui vogliamo permettere la navigazione in internet).</p> <p>Sintassi del comando: <code>access-list numeroACL permit/deny SOTTOINSIEME_INDIRIZZI_DA_TRADURRE WILDCARD_MASK</code></p> <pre><code>Router(config)# access-list 110 permit ip 192.168.0.0 0.0.0.15 any\n</code></pre> <p>Per concedere a tutti gli host configurati nella LAN di accedere ad internet (traduzione di tutti gli host nella LAN), posso utilizzare la sintassi</p> <pre><code>Router(config)# access-list numeroACL permit ip any any\n</code></pre> <p>Configurazione del servizio NAT sull\u2019interfaccia:</p> <pre><code>Router(config)# ip nat inside source list &lt;ACL_ID&gt; interface &lt;Interface_ID&gt; overload\n</code></pre> <p>Tutto il traffico definito dall\u2019ACL, verr\u00e0 inoltrato verso l\u2019esterno traducendo gli indirizzi privati con l\u2019indirizzo pubblico dell\u2019interfaccia FastEthernet 0/0.</p>"},{"location":"NAT/#port-forwarding","title":"Port Forwarding","text":"<p>Nel NAT Dinamico ed Overload, le traduzioni nella NAT Table vengono create solo quando il traffico parte dall\u2019interno della LAN e raggiunge l\u2019esterno (Mentre nel NAT Statico, sono configurate manualmente dall\u2019amministratore di rete, e rimangono indefinitamente nella memoria del router).</p> <p>Per esporre un host al di fuori della rete privata, in caso d\u2019uso di NAT Dinamico o Overload, dobbiamo utilizzare la funzionalit\u00e0 di port forwarding, ed impostare manualmente una regola di traduzione.</p> <p>Mapping tra indirizzo esterno e porta \u2192 indirizzo interno e porta servizio</p> <pre><code>Router(config)# ip nat inside source static tcp [IPInterno] [PortaInterna] [IPEsterno] [PortaEsterna]\n</code></pre>"},{"location":"Routing/","title":"Routing","text":"<p>Ricordando il concetto di Autonomous System (AS), cio\u00e8 un insieme di reti IP e router sotto il controllo di una singola entit\u00e0 amministrativa (es. un ISP, un'Universit\u00e0, una grande Azienda) che presenta al mondo Internet una politica di routing comune e coerente, ed ognuna con associato un identificativo a 16 o 32 bit (ASN), distinguiamo il routing in due livelli gerarchici:</p> <ul> <li>Routing IGP - Interno agli AS  (Include protocolli come OSPF, RIP)</li> <li>Routing EGP - Tra diversi AS (Protocollo BGP, gestisce l\u2019internet)</li> </ul> <p>In questa sezione, tratteremo esclusivamente Routing IGP.</p> <p>Il\u00a0Routing \u00e8 il processo di selezione da parte di un router, del percorso migliore per instradare i pacchetti di dati attraverso una rete.</p> <p>Per capire meglio in cosa consiste il routing, immaginiamo di modellare la rete come un grafo pesato \\(G=(V,E)\\), dove \\(V\\) \u00e8 l\u2019insieme dei router, \\(E\\) l\u2019insieme dei link, con i relativi costi associati.</p> <p>Sotto questa rappresentazione il compito del routing \u00e8 quello di determinare il cammino minimo tra due nodi sorgente e destinazione.</p>   **Problema**: per poter calcolare un cammino minimo tra due nodi, ogni router deve avere una conoscenza (completa o limitata) della rete. Dove teniamo traccia di tale conoscenza?   <p>Un Router, \u00e8 un sistema diviso concettualmente in due piani funzionali distinti:</p> <ul> <li> <p>Control Plane - La CPU e la RAM eseguono un sistema operativo per router, che si occupa di gestire le configurazioni statiche e i protocolli di routing dinamico.</p> <p>L\u2019output di questo piano \u00e8 la RIB (Routing Information Base), un database che racchiude la conoscenza che un router ha della rete.</p> <p>E\u2019 spesso ridondante (Potrebbe contenere pi\u00f9 rotte diverse per raggiungere la stessa destinazione, per esempio perch\u00e8 apprese secondo modalit\u00e0/protocolli differenti), non ottimizzata per la velocit\u00e0.</p> <p>Per questo, il control plane \u201cdistilla\u201d la RIB in una seconda tabella detta FIB (Forwarding Information Base), che contiene le sole rotte \u201cmigliori\u201d per ogni destinazione.</p> <p>Esempio di tabella di routing:</p> Codice Network Destination Prefisso (Mask) Next Hop / Gateway Interface AD Metric C <code>192.168.0.0</code> <code>/24</code> Directly Connected <code>Gig0/1</code> 0 0 L <code>192.168.0.100</code> <code>/32</code> Local (My IP) <code>Gig0/1</code> 0 0 S <code>0.0.0.0</code> <code>/0</code> <code>10.10.10.1</code> <code>Gig0/0</code> 1 0 O <code>172.16.0.0</code> <code>/16</code> <code>10.10.10.2</code> <code>Gig0/0</code> 110 20 <p>(Nota: C=Connessa, L=Locale, S=Statica, O=OSPF)</p> <p>Le rotte \u201cmigliori\u201d da installare nella FIB, sono selezionate considerando in ordine:</p> <ul> <li>Validit\u00e0 del next hop - Il router verifica se l\u2019indirizzo del next hop \u00e8 risolvibile: in caso negativo, la rotta viene scartata.</li> <li> <p>Longest Prefix Match - Supponiamo un router abbia due rotte per la stessa rete di destinazione:</p> <ul> <li>Rotta A: <code>192.168.10.0/24</code> (comprende gli hosts da .0 a .255)</li> <li>Rotta B: <code>192.168.10.0/28</code> (comprende gli hosts da .0 a .15)</li> </ul> <p>Arriva un pacchetto per <code>192.168.10.5</code>: entrambe le rotte sono valide, ma la Rotta B \u00e8 pi\u00f9 \u201cspecifica\u201d (maschera di sottorete pi\u00f9 lunga).</p> <p>Il router sceglier\u00e0 sempre la rotta pi\u00f9 specifica.</p> </li> <li> <p>Distanza Amministrativa - A Parit\u00e0 di \u201cprecisione\u201d di una rotta, si considera il valore del campo AD nella routing table.</p> <p>Questo numero indica al router \u201cquanto \u00e8 affidabile\u201d la fonte da cui ha appreso tale rotta.</p> <ul> <li>0:\u00a0Connessione diretta</li> <li>1:\u00a0Rotta statica (Impostata dall\u2019amministratore di rete)</li> <li>90:\u00a0EIGRP</li> <li>110:\u00a0OSPF</li> <li>200:\u00a0BGP</li> </ul> <p>Valori pi\u00f9 bassi = affidabilit\u00e0 pi\u00f9 elevata.</p> </li> <li> <p>Metrica - Costo associato ad una rotta, in termini di numero di hops, larghezza di banda. ritardo o affidabilit\u00e0 del collegamento.</p> </li> <li>Data Plane - Quando un pacchetto entra in un router, una porzione di hardware dedicata al forwarding sceglie dove inoltrarlo, riscrivendo l\u2019header di livello 2 cambiando il MAC sorgente con il proprio (del router), ed il MAC destinazione col MAC corrispondente al next hop IP preso dalla FIB.</li> </ul> <p>Decrementa il TTL, ricalcola checksum, inoltra il pacchetto sull\u2019interfaccia corrispondente al Next Hop IP.</p> <p> \ud83d\udca1 <p>Questa divisione in livelli, permette una robusta resistenza agli errori: se il Control Plane crasha (il software di routing si blocca), il router pu\u00f2 continuare a inoltrare pacchetti (compito del Data Plane) usando l'ultima FIB conosciuta.</p> <p>Capito dove memorizziamo la conoscenza della rete, esistono due modalit\u00e0 con cui un router pu\u00f2 apprenderla:</p> <ul> <li> <p>Routing statico - L\u2019amministratore di rete predispone manualmente i percorsi che i pacchetti dovranno seguire per arrivare ad una determinata rete, e li configura nel router sotto forma di voci nella RIB.</p> <p>Questo approccio prevede controllo totale sul traffico, oltre a prestazioni maggiori (I singoli router non hanno bisogno di calcolare da se le rotte del traffico, sono statiche ed impostate a priori).</p> <p>Tuttavia, scala molto male, sia in termini di complessit\u00e0 di configurazione iniziale (configurare rotte statiche su di una rete con 1000 router, \u00e8 sicuramente dispensioso), sia in evoluzione (ogni modifica della rete, richiede riconfigurazione manuale delle rotte).</p> <p> <p>Il Routing statico pu\u00f2 essere comunque utile in reti grandi, come \u201cpiano di backup\u201d in caso di crash dei protocolli di routing dinamico. Un amministratore di rete pu\u00f2 impostare delle rotte statiche con AD \u201cartificialmente\u201d molto alto (es: 200), che verranno utilizzate solo in caso il routing dinamico fallisse.</p> <li> <p>Routing dinamico - I Router automaticamente prendono conoscenza della topologia della rete, scambiandosi informazioni e calcolando i percorsi migliori.</p> </li>"},{"location":"Routing/#routing-statico","title":"Routing Statico","text":"<p>Nella topologia sopra illustrata, ogni coppia di router, appartiene ad una sottorete a se, con numero massimo di hosts pari a 2.</p> <p>La sottomaschera di queste reti sar\u00e0 /30 (Vogliamo configurare 2 hosts, riservando due indirizzi per base e broadcast, necessitiamo di un Host ID pari a 2 bit).</p> <p>Vogliamo permettere la comunicazione tra i due PC nelle LAN verde e lilla.</p> <p>Il Router 6 \u00e8 a conoscenza delle reti verde e gialla (poich\u00e8 direttamente connesso ad esse), ma non sa come raggiungere le reti azzurre e lilla.</p> <p>Impostiamo due rotte statiche per esse:</p> <p>Sintassi del comando di configurazione di una rotta statica: <code>router(config)# ip route &lt;Dst Net Base addr&gt; &lt;Dst Net mask&gt; &lt;Next hop IP addr&gt;</code></p> <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#ip route 192.168.0.4 255.255.255.252 192.168.0.2\nRouter(config)#ip route 192.168.10.0 255.255.255.0 192.168.0.2**\n</code></pre> <p>Router 5 conosce le reti gialla e azzurra, ma non conosce verde e lilla.</p> <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#ip route 192.168.10.0 255.255.255.0 192.168.0.6\nRouter(config)#ip route 192.168.1.0 255.255.255.0 192.168.0.1**\n</code></pre> <p>Router 7 conosce le reti azzurra e lilla, ma non conosce verde e gialla.</p> <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#ip route 192.168.0.0 255.255.255.252 192.168.0.5\nRouter(config)#ip route 192.168.1.0 255.255.255.0 192.168.0.5**\n</code></pre> <p></p> <p>Ogni router conosce ora l\u2019intera topologia della rete, la comunicazione tra i due PC \u00e8 consentita.</p>"},{"location":"Routing/#routing-dinamico","title":"Routing Dinamico","text":""},{"location":"Routing/#rip-routing-information-protocol","title":"RIP (Routing Information Protocol)","text":"<p>RIP \u00e8 un protocollo Distance Vector basato sull'algoritmo di Bellman-Ford. A differenza dei protocolli Link State, i router RIP NON hanno una mappa completa della rete: conoscono solo il costo totale per raggiungere una destinazione e il prossimo salto (Next Hop).</p> <p>Utilizza il protocollo di trasporto UDP.</p> <p>3 Versioni:</p> <ul> <li> <p>RIPv1</p> <p>Routing Classful: Non invia la Subnet Mask negli aggiornamenti di routing, per questo non supporta Subnetting VLSM (Variable Length Subnet Mask). E\u2019 in grado di annunciare sole reti /8, /16 o /24 (Classi A,B,C pure).</p> <p>Trasmissione: Invia gli aggiornamenti in Broadcast (255.255.255.255) ogni 30 secondi.</p> <p>Questo disturba ogni dispositivo nel dominio di broadcast (PC, stampanti ricevono il pacchetto, la NIC invia il pacchetto al S.O, rileva che non c\u2019\u00e8 nessun SW in ascolto per pacchetti RIP, lo scartano).</p> <p>Sicurezza: Nessuna autenticazione. Chiunque colleghi un router pirata pu\u00f2 iniettare rotte false e dirottare il traffico.</p> </li> <li> <p>RIPv2</p> <p>Routing Classless: Invia la Subnet Mask insieme all'indirizzo IP. Supporta pienamente VLSM e CIDR.</p> <p>Trasmissione: Trasmette gli aggiornamenti in multicast ai soli router RIP (Gruppo multicast)</p> <p>Sicurezza: Supporta autenticazione (MD5 o Clear Text). Il router accetta aggiornamenti solo se la password corrisponde.</p> </li> <li> <p>RIPng</p> <p>Aggiunge supporto ad IPv6</p> </li> </ul>"},{"location":"Routing/#funzionamento-di-rip","title":"Funzionamento di RIP:","text":"<p>Analizziamo la topologia in figura: all\u2019avvio, ogni router riempie la propria tabella di routing inserendo le informazioni relative alle reti direttamente connesse. (Type = C (Connected), Metric=0)</p> <p></p> <p>Ogni 30 secondi, i router inviano e ricevono un\u2019informazione ridotta della tabella di routing dei vicini, che contiene:</p> <ul> <li>Reti conosciute</li> <li>Costo (Metrica, espressa in \u201cNumero di router da attraversare\u201d per poter arrivare alla rete destinazione)</li> </ul> <p>Per ogni destinazione nella tabella del vicino, il router calcola: \\(HopCount_{new} = HopCount_{vicino} + 1\\) (Dove \"+1\" \u00e8 il costo per raggiungere il vicino stesso).</p> <p>Fatto questo calcolo, applica due regole logiche:</p> <ul> <li> <p>Discovery</p> <p>Se la destinazione che sto analizzando, \u00e8 sconosciuta per la mia tabella di routing, procedo ad \u201cimpararla\u201d.</p> <p>Aggiungo alla mia tabella una entry contenente la rete che sto imparando, l\u2019interfaccia che mi collega al vicino, la metrica calcolata.</p> </li> <li> <p>Update</p> <p>Se la destinazione che sto analizzando \u00e8 gi\u00e0 conosciuta, ma la metrica calcolata \u00e8 minore, vuol dire che ho appreso una nuova strada pi\u00f9 veloce.</p> <p>Aggiorno la rotta con il nuovo valore per HopCount, ed impostando come next hop il vicino dal quale ho ricevuto la tabella.</p> </li> </ul> <p></p> <p>Ora ogni router ha le informazioni necessarie per comunicare con l\u2019intera rete.</p> <p>Provando a trasmettere un messaggio tra PC2 e PC0, esso seguir\u00e0 il percorso: PC2 \u2192 Router2 \u2192 Router0\u2192 PC0</p> <p></p> <p>Simuliamo un guasto tra Router2 e Router0</p> <p></p> <p>Viene immediatamente segnalato il guasto del link (Triggered Update, senza dover aspettare il timer standard di 30 secondi), attraverso lo scambio di informazioni standard. </p> <p>Router2 Aggiorna la propria rotta verso la rete del PC0, impostando Router1 come Next Hop.</p>"},{"location":"Routing/#configurazione-ripv1-in-packet-tracer","title":"Configurazione RIPv1 in Packet Tracer:","text":"<p>Situazione iniziale: Ogni router conosce le sole reti direttamente connesse.</p> <p></p> <p>Partiamo dal Router0. Esso dovr\u00e0 annunciare la conoscenza della rete 192.168.1.0 (Quella in cui si trova PC0), e della rete 192.168.0.0 (Quella che collega i 3 router assieme).</p>   RIPv1 \u00e8 classful, pertanto dobbiamo annunciare l\u2019intera rete 192.168.0.0/24, e non le singole sottoreti che collegano le coppie di router.   <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#router rip\nRouter(config-router)#network 192.168.1.0\nRouter(config-router)#network 192.168.0.0\nRouter(config-router)#passive-interface GigabitEthernet 2/0**\n</code></pre> <p>Il comando <code>router rip</code> ordina al sistema operativo di avviare il demone software di RIP. Di default, la versione eseguita \u00e8 RIPv1.</p> <p>Col comando <code>network A.B.C.D</code>, il demone RIP esegue due azioni:</p> <ul> <li>Scansiona tutte le porte fisiche del router, rileva le interfacce associate alla rete indicata, e le attiva per la ricezione di pacchetti RIP.</li> <li>Comincia ad annunciare tale rete ai vicini.</li> </ul> <p>Eseguendo il comando <code>network 192.168.1.0</code>, il router comincer\u00e0 quindi contemporaneamente ad annunciare la conoscenza di tale rete ai vicini (corretto), ma anche ad inoltrare i pacchetti RIP all\u2019interno della LAN (comportamento indesiderato).</p> <p>Con <code>passive-interface GigabitEthernet 2/0</code>, dove <code>GigabitEthernet 2/0</code> \u00e8 l\u2019interfaccia associata alla LAN 192.168.1.0, indichiamo al router di smettere di inviare pacchetti RIP ad essa, pur continuando ad annunciare la rete agli altri router.</p> <p>Ripetiamo per Router1:</p> <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#router rip\nRouter(config-router)#network 192.168.10.0\nRouter(config-router)#network 192.168.0.0\nRouter(config-router)#passive-interface GigabitEthernet 1/0**\n</code></pre> <p>Router2:</p> <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#router rip\nRouter(config-router)#network 192.168.20.0\nRouter(config-router)#network 192.168.0.0\nRouter(config-router)#passive-interface Ethernet 2/0**\n</code></pre> <p></p> <p>I Router hanno correttamente cominciato a scambiarsi messaggi RIP.</p>"},{"location":"Routing/#configurazione-ripv2-in-packet-tracer","title":"Configurazione RIPv2 in Packet Tracer:","text":"<p>Operiamo sulla stessa topologia indicata sopra.</p> <p>RIPv2 \u00e8 classless, dobbiamo quindi annunciare singolarmente tutte le sottoreti (anche le /30 tra router).</p> <p>Router0:</p> <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#router rip\nRouter(config-router)#version 2\nRouter(config-router)#network 192.168.1.0\nRouter(config-router)#network 192.168.0.4\nRouter(config-router)#network 192.168.0.0**\n</code></pre> <p>Router1:</p> <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#router rip\nRouter(config-router)#version 2\nRouter(config-router)#network 192.168.10.0\nRouter(config-router)#network 192.168.0.0\nRouter(config-router)#network 192.168.0.8**\n</code></pre> <p>Router2:</p> <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#router rip\nRouter(config-router)#version 2\nRouter(config-router)#network 192.168.0.4\nRouter(config-router)#network 192.168.0.8\nRouter(config-router)#network 192.168.20.0**\n</code></pre>   Nota! RIPv2 trasmette gli aggiornamenti in modalit\u00e0 multicast. La trasmissione in modalit\u00e0 multicast, implica comunque che i pacchetti vengono inoltrati in modalit\u00e0 flooding su tutte le interfacce, ma vengono scartati dalla NIC del destinatario (dopo un check sul MAC destinatario).  I PC nella LAN quindi ricevono comunque i pacchetti RIP, e seppur scartati dalla NIC, un utente smaliziato potrebbe usare un analizzatore di rete (es: Wireshark) per catturare i pacchetti RIP e acquisire conoscenza della rete.  **E\u2019 pertanto comunque consigliato eseguire il comando passive-interface anche in RIPv2!**   <p></p>"},{"location":"Routing/#ospf-open-shortest-path-first","title":"OSPF (Open Shortest Path First)","text":"<p>OSPF \u00e8 un protocollo di routing Link State basato direttamente su IP.</p> <p>A differenza di RIP, ogni router OSPF acquisisce conoscenza dell\u2019intera topologia della porzione di rete in cui si trova, che utilizzer\u00e0 per calcolare localmente i cammini minimi verso ogni destinazione.</p> <p></p> <p>Per far funzionare tutto questo, il router deve gestire tre archivi distinti nella sua memoria:</p> <ul> <li>Neighbor Table - Lista dei router adiacenti (direttamente connessi), con i loro indirizzi IP, Interfacce, Router ID, Stato.</li> <li>Topology Table (LSDB - Link State Database) - Lista di tutti gli LSA (Link State Advertisements) raccolti. Rappresenta la mappa completa della rete.</li> <li>Routing Table - Popolata coi soli percorsi migliori, calcolati eseguendo l\u2019algoritmo di Dijkstra sulle informazioni contenute nelle due tabelle precedenti.</li> </ul>"},{"location":"Routing/#funzionamento-di-ospf","title":"Funzionamento di OSPF","text":"<ul> <li> <p>Inizializzazione del processo OSPF</p> <pre><code>Router# config term # accedere alla config mode\nRouter(config)# router ospf 1 # avvio il processo OSPF, con Process ID pari ad 1 (questo serve ad identificare eventuali multiple istanze di OSPF in esecuzione sullo stesso router)\n</code></pre> <p>Automaticamente, viene assegnato al router un ID univoco a 32bit (RID), con il quale esso potr\u00e0 identificarsi.</p> <p></p> <p>Selezione delle interfacce da annunciare durante lo scambio di messaggi:</p> <pre><code> Router(config)# network &lt;ip-address&gt; &lt;wildcard-mask&gt; area &lt;area-id&gt;\n</code></pre> <p>Tutte le interfacce il cui indirizzo rientra (match) nella combinazione ip-address e wildcard-mask indicata:</p> <ul> <li>Verranno annunciate ai router adiacenti.</li> <li>Saranno destinazione di traffico OSPF</li> </ul> <p> <p>Vogliamo evitare di inviare pacchetto OSPF in reti composte da soli hosts (LAN).</p> <p>Per fare ci\u00f2, possiamo impostare le interfacce in modalit\u00e0 passiva</p> <pre><code>Router(config-router)# passive-interface GigabitEthernet0/0\n</code></pre> <li> <p>Inizio del processo di adiacenza</p> <p></p> <ul> <li>Stato iniziale (DOWN): Entrambi i router hanno Neighbor Table vuota.</li> <li> <p>R1 invia un pacchetto HELLO in Multicast a <code>224.0.0.5</code> (Gruppo a cui appartengono tutti i router OSPF)</p> <p>Contenuto Pacchetto R1:</p> <ul> <li>Source OSPF Router ID: <code>1.1.1.1</code></li> <li>Active Neighbor Field: <code>[VUOTO]</code> (R1 non conosce nessuno).</li> </ul> <p>R2 riceve il pacchetto, controlla i parametri (Area, Subnet, Password, Hello Timer), vede che il campo \u201cActive Neighbor\u201d \u00e8 vuoto, capisce che R1 non \u00e8 ancora a sua conoscenza.</p> <p>R2 registra R1 nella sua Neighbor Table, impostandone lo stato a INIT.</p> <p>INIT = Conosco R1, ma lui ancora non conosce me. La comunicazione \u00e8 unidirezionale.</p> </li> <li> <p>R2 risponde con un nuovo pacchetto HELLO</p> <p>Contenuto del Pacchetto R2:</p> <ul> <li>Source OSPF Router ID: <code>2.2.2.2</code></li> <li>Active Neighbor Field: <code>1.1.1.1</code></li> </ul> <p>R1 lo riceve, legge il campo Source OSPF Router ID, riconosce la corrispondenza tra il suo RID e il campo Active Neighbor: Vuol dire che il suo precedente pacchetto HELLO \u00e8 stato raggiunto da 2.2.2.2, che ne ha registrato la presenza.</p> <p>R1 registra R2 nella sua neighbor table con lo stato 2WAY: ora entrambi sono a conoscenza l\u2019uno dell\u2019altro.</p> </li> <li> <p>R1 risponde con un ultimo HELLO con 2.2.2.2 nel campo Active Neighbor, cos\u00ec che anche R2 imposti lo stato 2WAY.</p> </li> <li>Scambio di Link State Advertisement</li> </ul> <p>Prima di inviare dati, ogni coppia di router si sincronizza per eleggere un Master e uno Slave.</p> <p>In figura, 1.1.1.1 \u00e8 il master (Nella maggior parte dei casi in realt\u00e0, il master \u00e8 quello con RID pi\u00f9 alto, in questo caso sarebbe 2.2.2.2)</p> <p></p> <p>1.1.1.1 invia un pacchetto DBD, in cui \u00e8 contenuto un sommario del suo LSDB (I soli LSA Headers). Inviamo i soli header e non l\u2019intero LSDB, poich\u00e9 per ogni coppia di router, i due LSDB differiranno ad uno stesso momento per poche informazioni. Sarebbe uno spreco trasmettere l\u2019intero LSDB.</p> <p>Anche 2.2.2.2 invia i propri headers.</p> <p>1.1.1.1 confronta gli header ricevuti con il proprio LSDB.</p> <p>Per ognuno, se il LSA manca o se quello ricevuto \u00e8 pi\u00f9 recente, viene aggiunto alla LSA Request List.</p> <p>Ipotizziamo 1.1.1.1 rilevi che gli manchino 50 LSA per essere sincronizzato:</p> <ul> <li>1.1.1.1 genera un (o pi\u00f9, si inseriscono quante pi\u00f9 richieste possibili compatibilmente con MTU) pacchetto LSR. Al suo interno c'\u00e8 la lista degli ID di tutti i 50 LSA mancanti.</li> <li>2.2.2.2 riceve la lista. Supponiamo che ogni LSA completo pesi 100 Byte. Totale dati: 50 * 100 = 5000$ Byte. L'MTU \u00e8 1500 Byte. R2 non pu\u00f2 mandare tutto in un pacchetto. R2 invier\u00e0 4 pacchetti LSU (Link State Update): \u2022 LSU #1 (Primi 14 LSA) \u2022 LSU #2 (Secondi 14 LSA) \u2022 LSU #3 (Terzi 14 LSA) \u2022 LSU #4 (Ultimi 8 LSA)</li> <li>1.1.1.1 conferma la ricezione dei LSA con un ACK cumulativo.</li> </ul> <p>La procedura si ripete con 2.2.2.2 che richiede i LSA mancanti.</p> <p>Al termine, gli LSDB dei due router sono sincronizzati (Stato FULL), eseguono l\u2019algoritmo di Dijkstra per popolare la tabella di routing.</p> </li> <li> <p>Segnalazione di cambiamenti nella topologia di rete</p> <p>Dopo la sincronizzazione (stato FULL), la rete \u00e8 silenziosa. I router inviano solo piccoli Hello ogni 10s (Keepalive). Se per\u00f2 cade un link o cambia qualcosa, il router che rileva il guasto invia immediatamente un LSU in flooding.</p> <p>Tutti i router ricevono l'aggiornamento, aggiornano l'LSDB ed eseguono di nuovo Dijkstra.</p> </li>"},{"location":"Routing/#metrica","title":"Metrica","text":"<p>In ogni pacchetto LSU, \u00e8 associata ai LSA una metrica che OSPF calcola come:</p> <p>\\(Metric=\\frac{Reference Bandwidth(Mbps)}{LinkBandwidth(Mbps)}\\)</p> <p>Questo valore \u00e8 ci\u00f2 che l\u2019algoritmo di Dijkstra minimizza durante il calcolo dei percorsi migliori.</p> <p></p>"},{"location":"Routing/#aree","title":"Aree","text":"<p>Per garantire la scalabilit\u00e0 e impedire che l'LSDB raggiunga dimensioni troppo elevate su reti vaste, OSPF divide logicamente gli AS in Aree.</p> <p></p> <p>Questa segmentazione crea una gerarchia a due livelli:</p> <ol> <li>Dominio di Flooding Ridotto: Ogni Area mantiene il proprio LSDB. </li> <li>Isolamento dei Guasti: Se un link cade nell'Area 1, l'algoritmo SPF viene ricalcolato solo dai router dell'Area 1.</li> </ol> <p></p> <p>Tra le varie tipologie, utilizzeremo la Stub Area. \u00c8 una configurazione ottimizzata di OSPF che filtra le rotte esterne al Sistema Autonomo (LSA Type 5), impedendo che entrino nell\u2019LSDB (riducendone le dimensioni) Per raggiungere destinazioni esterne, la Stub Area utilizza una Default Route (<code>0.0.0.0/0</code>) iniettata automaticamente dal router di confine (ABR), delegando a lui ogni decisione di instradamento verso l'esterno. (In figura, il router di confine per l\u2019area 1 \u00e8 R1) </p>"},{"location":"Routing/#configurazione-ospf-in-packet-tracer","title":"Configurazione OSPF in Packet Tracer","text":"<p>Router 0:</p> <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#router ospf 1\nRouter(config-router)# area 1 stub #configurazione area stub\nRouter(config-router)#network 192.168.1.0 0.0.0.255 area 1 #annuncio reti\nRouter(config-router)#network 192.168.0.0 0.0.0.3 area 1\nRouter(config-router)#network 192.168.0.4 0.0.0.3 area 1\nRouter(config-router)#passive-interface GigabitEthernet2/0 #non inoltro pacchetti OSPF nella LAN**\n</code></pre> <p>Router 1:</p> <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#router ospf 1\nRouter(config-router)# area 1 stub\nRouter(config-router)#network 192.168.10.0 0.0.0.255 area 1\nRouter(config-router)#network 192.168.0.0 0.0.0.3 area 1\nRouter(config-router)#network 192.168.0.8 0.0.0.3 area 1\nRouter(config-router)#passive-interface GigabitEthernet1/0**\n</code></pre> <p>Router 2:</p> <pre><code>**Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#router ospf 1\nRouter(config-router)# area 1 stub\nRouter(config-router)#network 192.168.20.0 0.0.0.255 area 1\nRouter(config-router)#network 192.168.0.4 0.0.0.3 area 1\nRouter(config-router)#network 192.168.0.8 0.0.0.3 area 1\nRouter(config-router)#passive-interface Ethernet2/0**\n</code></pre> <p></p> <p>Con il comando <code>show ip ospf neighbor</code>, verifichiamo che le connessioni con i vicini siano in stato FULL, ad indicare che gli LSDB sono stati correttamente sincronizzati.</p>"},{"location":"VLAN/","title":"VLAN","text":"<p>Le VLAN (Virtual Local Area Network) permettono di segmentare la rete Ethernet in pi\u00f9 reti Layer 2 separate, senza switch distinti. Permettono quindi di separare logicamente in pi\u00f9 domini di broadcast, un gruppo di host connesso mediante la stessa infrastruttura fisica.</p> <p>Voglio dividere un gruppo di hosts in due reti logiche, al fine di isolarne il traffico. Identifichiamo due gruppi, verde e arancio.</p>"},{"location":"VLAN/#soluzione-1","title":"Soluzione 1:","text":"<p>Collego allo switch a SX solo i PC del gruppo arancione, e allo switch di destra solo i PC del gruppo verde. Per far si che due PC in LAN diverse possano comunicare, introduciamo un router per la comunicazione a livello 3.</p> <p>Questa soluzione \u00e8 poco scalabile: e se i PC appartenenti ad uno stesso gruppo si trovassero in uffici diversi? Dovrei tirare dei cavi lunghissimi.</p>"},{"location":"VLAN/#soluzione-2","title":"Soluzione 2:","text":"<p>Collego gli switch con tanti cavi quante sono le VLAN. Ogni porta sullo switch, \u00e8 configurata in modalit\u00e0 ACCESS. Su ogni cavo che collega due switch, viagger\u00e0 il traffico relativo ad una sola specifica VLAN.</p> <p>Anche questa soluzione scala male all\u2019aumentare del numero di VLAN.</p>"},{"location":"VLAN/#trunking-ieee8021q","title":"Trunking IEEE802.1Q","text":"<p>Lo standard IEEE 802.1Q definisce il VLAN Trunking, che permette al traffico di pi\u00f9 VLAN di viaggiare lungo un singolo collegamento fisico (trunk).</p> <p></p> <p></p> <p>802.1Q aggiunge 4 byte all\u2019header di ogni frame ethernet, al fine di identificarne la VLAN di appartenenza (Frame tagging):</p> <p></p> <ul> <li> <p>I primi 2 byte riguardano il\u00a0tag protocol identifier (TPID).</p> <p>Il suo valore \u00e8 impostato a 0x8100, ad indicare che il frame trasmesso \u00e8 in formato IEEE 802.1Q.</p> </li> <li> <p>I successivi 2 byte riguardano il\u00a0tag control information TCI\u00a0(detto anche\u00a0**VLAN\u00a0Tag**) cos\u00ec suddiviso:</p> <ul> <li>Priority Code Point (PCP): Questo campo a 3 bit pu\u00f2 essere utilizzato per indicare un livello di priorit\u00e0 per il frame. L'utilizzo di questo campo \u00e8 definito in:\u00a0IEEE 802.1p.</li> <li>Drop eligible indicator (DEI): (in precedenza CFI) Campo di 1 bit che indica la possibilit\u00e0 di ignorare il frame in caso di congestione.</li> <li> <p>VLAN ID (VID): campo di 12 bit che indica l'ID delle VLAN (fino a 4096 VLAN identificabili)</p> <p>Di queste, la prima (VLAN 0) e l'ultima (VLAN 4095) sono riservate</p> </li> </ul> </li> </ul> <p>Il resto del frame Ethernet rimane identico all'originale.</p> <p>Capiamo allora che ogni interfaccia di uno switch, pu\u00f2 operare in due modalit\u00e0:</p> <ul> <li>Access - Su quell\u2019interfaccia viaggia il traffico destinato ad una sola VLAN (frame untagged).</li> <li>Trunk - Accettano e trasmettono frame tagged, gestiscono traffico da/a pi\u00f9 VLAN (IEEE 802.1Q)</li> </ul>"},{"location":"VLAN/#configurazione-packet-tracer","title":"Configurazione Packet Tracer","text":"<p>Realizziamo la topologia in figura:</p> <p></p> <p>Configurazione switch di sinistra:</p> <pre><code>**enable** # accesso alla modalit\u00e0 privilegiata\n**configure terminal** # accesso alla configurazione globale\n\n***Aggiungiamo le VLAN al database dello switch***\n\n**vlan 10** # aggiunta della VLAN con ID 10 al database dello switch\n**name verde1**0 # assegnazione del nome alla VLAN 10 (sub mode vlan)\n\n**exit** # torna al livello configurazione globale\n\n**vlan 20** # aggiunta della VLAN con ID 20 al database dello switch\n**name arancio20** # assegnazione del nome alla VLAN 20 (submode vlan)\n**exit** # torna al livello configurazione globale\n\n***Configuriamo le interfacce in modalit\u00e0 access (verso gli host)***\n\n**interface Fastethernet 0/1** # accesso alla submode di conf. dell\u2019interfaccia 0/1\n**switchport mode access** # configurazione dell\u2019interfaccia in modalit\u00e0 access\n**switchport access vlan 20** # indicazione della VLAN presente su quella porta\n\nexit # torna al livello configurazione global\n\n**interface Fastethernet 1/1** # accesso alla submode di conf. dell\u2019interfaccia 1/1\n**switchport mode access** # configurazione dell\u2019interfaccia in modalit\u00e0 access\n**switchport access vlan 10** # indicazione della VLAN presente su quella porta\n\n**exit** # torna al livello configurazione globale\n\n***Configuriamo l'interfaccia trunk (verso l'altro switch)*\n\ninterface Fastethernet 2/1** # accesso alla submode di conf. dell\u2019interfaccia 2/1\n**switchport mode trunk** # configurazione dell\u2019interfaccia in modalit\u00e0 trunk\n**switchport trunk allowed vlan 10** # consentire il passaggio del traffico della VLAN 10\n**switchport trunk allowed vlan add 20** # aggiunta della VLAN 20 a quelle permesse\n\n**exit** # torna al livello configurazione globale\n**exit** # esci dalla configurazione globale\n**write** # salva\n</code></pre> <p>Configurazione switch di destra:</p> <pre><code>Switch&gt;enable\nSwitch#configure terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#vlan 10\nSwitch(config-vlan)#name verde10\nSwitch(config-vlan)#exit\nSwitch(config)#vlan 20\nSwitch(config-vlan)#name arancio20\nSwitch(config)#interface FastEthernet0/1\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 20\nSwitch(config-if)#exit\nSwitch(config)#interface FastEthernet1/1\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 10\nSwitch(config-if)#exit\nSwitch(config)#interface FastEthernet2/1\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 10\nSwitch(config-if)#exit\nSwitch(config)#interface FastEthernet3/1\nSwitch(config-if)#switchport mode trunk\nSwitch(config-if)#switchport trunk allowed vlan 10\nSwitch(config-if)#switchport trunk allowed vlan add 20\nSwitch(config-if)#exit\nSwitch(config)#exit\nSwitch#\n%SYS-5-CONFIG_I: Configured from console by console\nwrite\nBuilding configuration...\n[OK]\n</code></pre>"},{"location":"VLAN/#routing-inter-vlan","title":"Routing Inter-VLAN","text":"<p>Il Routing Inter-VLAN permette la comunicazione tra due o pi\u00f9 VLAN. Per fare ci\u00f2, \u00e8 necessario un dispositivo di livello 3 (Che svolga la funzionalit\u00e0 di Routing, quindi un Router o Switch di livello 3).</p> <p>Ad ogni VLAN, \u00e8 assegnato un Indirizzo IP \u201cGateway\u201d, che permette al traffico di uscire al di fuori del dominio di broadcast.</p>"},{"location":"VLAN/#metodo-1-collegamenti-fisici-dedicati","title":"Metodo 1: Collegamenti fisici dedicati","text":"<p>Per ogni VLAN, si riserva un\u2019interfaccia sul router (ed un conseguente link fisico) dedicata, il cui indirizzo IP sar\u00e0 il default gateway per la singola VLAN.</p> <p>Soluzione poco scalabile, utilizzata solo in caso di gestione di 2/3 VLAN.</p>"},{"location":"VLAN/#metodo-2-router-on-a-stick","title":"Metodo 2: Router on a stick","text":"<p>Si utilizza un singolo link fisico (Stick, o Trunk Link) tra switch e router, per gestire il traffico di tutte le VLAN.</p> <p></p> <p>Questo approccio si basa sulla capacit\u00e0 del router di creare sottointerfacce logiche su una singola interfaccia fisica, ciascuna delle quali agisce come un gateway per una VLAN specifica.</p> <p>La porta dello switch a cui \u00e8 collegato il router, deve essere configurata in modalit\u00e0 Trunk, per poter veicolare il traffico di pi\u00f9 VLAN contemporaneamente.</p> <p>L\u2019interfaccia fisica del router, viene divisa logicamente in sottointerfacce.</p> <p>Nel disegno, l\u2019interfaccia FastEthernet0/0, viene divisa in FastEthernet0/0.50 per la VLAN 50, FastEthernet0/0.60 per la VLAN 60,FastEthernet0/0.70 per la VLAN 70.</p> <p>Ognuna, viene configurata con un indirizzo IP, che funge da default gateway per la sua specifica VLAN.</p> <p>Esempio di comunicazione:</p> <p></p> <p>Il PC \u201cSource\u201d (IP: 192.168.1.3), nella VLAN \u201cMagazzino\u201d (ID 10), vuole inviare un pacchetto ICMP (Protocollo di livello 3, pertanto verr\u00e0 generato un pacchetto IP) al PC Destination (IP: 192.168.0.4), nella VLAN \u201cUffici\u201d (ID 20).</p> <p></p> <p>\u201cSource\u201d, verificando l\u2019IP destinazione con la subnet mask, rileva che non \u00e8 nella sua stessa rete. </p> <p>Imposta il campo DEST ADDR, con l\u2019indirizzo MAC del suo default gateway (DST IP rimane l\u2019indirizzo IP di \u201cDestination\u201d). </p> <p>Lo switch riceve il frame (Livello 2).</p> <p>Esiste gi\u00e0 una corrispondenza MAC-Interface, pertanto non aggiorna la tabella ARP.</p> <p></p> <p>Supponendo lo switch abbia gi\u00e0 in memoria la corrispondenza tra il MAC del default gateway e la relativa interfaccia, esso sapr\u00e0 di dover inoltrare il frame su un link Trunk: il frame viene taggato con l\u2019ID 10 della VLAN \u201cMagazzino\u201d.</p> <p>Il Router riceve il pacchetto (Livello 3).</p> <p>Controlla l\u2019ID della VLAN: L\u2019interfaccia FastEthernet0/0.10 accetta frame da quella VLAN.</p> <p>All\u2019interno dell\u2019header, il MAC Address di destinazione \u00e8 il suo, ma l\u2019indirizzo IP no. Il Router cos\u00ec sa che questo pacchetto non \u00e8 destinato a lui, ma dovr\u00e0 inoltrarlo.</p> <p></p> <p>Attraverso un lookup della tabella ARP, riconosce una corrispondenza tra l\u2019indirizzo IP destinazione, e la coppia MAC Address e interfaccia.</p> <p>Il Router sostituisce il MAC Address del PC \u201cDestination\u201d, inserisce l\u2019ID 20 per la VLAN (Questo viene ricavato dall\u2019ID associato all\u2019interfaccia), e inoltra il pacchetto all\u2019interfaccia FastEthernet0/0.20.</p> <p>Lo switch riceve nuovamente indietro il frame. Questo \u00e8 taggato con l\u2019ID 20. </p> <p>Controlla la MAC Table, ha una corrispondenza per l\u2019indirizzo destinazione.</p> <p>Rimuove il tag VLAN, e inoltra correttamente il frame untagged a destinazione.</p> <p>Configurazione Packet Tracer:</p> <ul> <li>Configurare l\u2019interfaccia che va dallo switch al router in modalit\u00e0 Trunk per tutte le VLAN.</li> <li> <p>Sul Router, suddividere l\u2019interfaccia connessa, e impostarla come default gateway per ogni VLAN:</p> <pre><code>**Router(config)# interface FastEthernet 0/0.20** # Suddivido l'interfaccia logica 0/0, nell'interfaccia 0/0.20\n**Router(config-subif)# encapsulation dot1Q 20 #** Abilito incapsulamento 802.1Q. Questa interfaccia logica, sar\u00e0 dedicata alla VLAN 20.\n**Router(config-subif)# ip address &lt;addr&gt; &lt;netmask&gt;** # Imposto questa interfaccia come default gateway per la VLAN 20, assegnandone un indirizzo IP.\n**Router(config-subif)# no shutdown** # Accendo interfaccia\n**Router(config-subif)# exit**\n</code></pre> <p>Ripeto per tutte le VLAN.</p> </li> </ul>"}]}